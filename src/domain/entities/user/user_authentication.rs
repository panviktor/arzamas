use crate::domain::entities::shared::value_objects::OtpCode;
use crate::domain::entities::shared::{Email, IPAddress, OtpToken, UserAgent, Username};
use crate::domain::entities::user::user_security_settings::UserSecuritySettings;
use crate::domain::entities::user::user_sessions::UserSession;
use chrono::{DateTime, Utc};

#[derive(Debug, Clone)]
pub enum AuthenticationOutcome {
    /// The first step is ok, but user needs email verification.
    RequireEmailVerification {
        otp_token: OtpToken,
        otp_code: OtpCode,
        email: Email,
    },
    /// The first step is ok, but user needs 2FA Authenticator verification
    RequireAuthenticatorApp {
        otp_token: OtpToken,
        email: Email,
        email_notifications_enabled: bool,
    },
    /// The first step is ok, but user needs both email and 2FA Authenticator verification
    RequireEmailAndAuthenticatorApp {
        otp_token: OtpToken,
        otp_code: OtpCode,
        email: Email,
    },
    /// Successfully authenticated and session stored in Redis
    AuthenticatedWithPreferences {
        session: UserSession,
        email: Email,
        message: String,
        email_notifications_enabled: bool,
    },
    /// Login failed (password/2FA)
    AuthenticationFailed {
        email: Email,
        message: String,
        email_notifications_enabled: bool,
    },
    /// User has logged in with user and password, awaiting 2FA authentication
    PendingVerification { message: String },
    /// User hasn't activated email token after registration
    UserEmailConfirmation { email: Email, token: OtpToken },
}

#[derive(Debug)]
pub struct UserAuthentication {
    pub user_id: String,
    pub username: Username,
    pub email: Email,
    pub pass_hash: String,
    pub email_validated: bool,
    pub security_setting: UserSecuritySettings,
    pub auth_data: UserAuthenticationData,
    pub sessions: Vec<UserSession>,
}

/// `UserAuthenticationData` holds the necessary details for handling One-Time Passwords (OTP)
/// for both email and authenticator app-based two-factor authentication (2FA) mechanisms.
///
/// This structure is used to validate OTPs entered by users during the login process
/// and to manage the lifecycle and validity of these tokens.
#[derive(Debug)]
pub struct UserAuthenticationData {
    /// Hash of the OTP sent via email. This is used for verifying the OTP entered by the user.
    pub otp_email_code_hash: Option<OtpCode>,

    /// Indicates whether the current email OTP is valid. This is typically set to `true`
    /// when an OTP is generated and set to `false` when it expires or is used. This flag
    /// should be updated based on `otp_email_valid_time` to reflect the current state
    /// without needing to constantly compare times.
    pub otp_email_currently_valid: bool,

    /// Hash of the OTP generated by an authenticator app. This hash is used to verify the OTP
    /// entered by the user matches the expected value.
    pub otp_app_hash: Option<String>,

    /// Indicates whether the current app OTP is valid.
    /// This flag is used to quickly check the validity of the app OTP without repeated time comparisons.
    /// It must be managed carefully to ensure it accurately reflects the state based on `otp_app_valid_time`.
    pub otp_app_currently_valid: bool,

    /// General expiration time for the OTP token session. This might control the entire session's validity
    /// for OTP entry and should be checked before accepting any OTP entries.
    pub expiry: Option<DateTime<Utc>>,

    /// Count of failed OTP attempts. This can be used to implement rate limiting or account locking mechanisms
    /// after a certain number of failed attempts to prevent brute force attacks.
    pub attempt_count: i64,

    /// A string representing the user agent of the client during the OTP transaction.
    /// This information can be useful for auditing purposes and to enhance security measures,
    /// helping to determine the legitimacy of the request based on known characteristics of the client's software.
    pub user_agent: Option<UserAgent>,

    /// The IP address from which the OTP request was made. Recording IP addresses can aid in security audits
    /// and help in identifying suspicious activities or patterns of abuse, such as repeated failed attempts
    /// from the same IP address or unusual locations.
    pub ip_address: Option<IPAddress>,

    /// Indicates if the session is a long session.
    /// By default, sessions are valid for 24 hours.
    /// This flag can be used to extend the session duration for trusted devices or scenarios.
    pub long_session: bool,

    /// The datetime until which the user is blocked from logging in.
    /// This can be used to enforce a cooldown period after multiple failed login attempts.
    pub login_blocked_until: Option<DateTime<Utc>>,
}
