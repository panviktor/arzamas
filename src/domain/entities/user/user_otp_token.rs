use crate::domain::entities::shared::value_objects::{IPAddress, UserAgent};
use chrono::{DateTime, Utc};

/// `UserOtpToken` holds the necessary details for handling One-Time Passwords (OTP)
/// for both email and authenticator app-based two-factor authentication (2FA) mechanisms.
///
/// This structure is used to validate OTPs entered by users during the login process
/// and to manage the lifecycle and validity of these tokens.
#[derive(Debug)]
pub struct UserOtpToken {
    /// Unique identifier for the user associated with these tokens.
    pub user_id: String,

    /// Hash of the OTP sent via email. This is used for verifying the OTP entered by the user.
    pub otp_email_hash: Option<String>,

    /// Indicates whether the current email OTP is valid. This is typically set to `true`
    /// when an OTP is generated and set to `false` when it expires or is used. This flag
    /// should be updated based on `otp_email_valid_time` to reflect the current state
    /// without needing to constantly compare times.
    pub otp_email_currently_valid: bool,

    /// Hash of the OTP generated by an authenticator app. This hash is used to verify the OTP
    /// entered by the user matches the expected value.
    pub otp_app_hash: Option<String>,

    /// Indicates whether the current app OTP is valid.
    /// this flag is used to quickly check the validity of the app OTP without repeated time comparisons.
    /// It must be managed carefully to ensure it accurately reflects the state based on `otp_app_valid_time`.
    pub otp_app_currently_valid: bool,

    /// Optional mnemonic for the OTP. This is used for recovery purposes and should be handled with
    /// care to avoid security risks. It's typically not recommended to store this unless absolutely necessary.
    pub otp_app_mnemonic: Option<String>,

    /// General expiration time for the OTP token session. This might control the entire session's validity
    /// for OTP entry and should be checked before accepting any OTP entries.
    pub expiry: Option<DateTime<Utc>>,

    /// Count of failed OTP attempts. This can be used to implement rate limiting or account locking mechanisms
    /// after a certain number of failed attempts to prevent brute force attacks.
    pub attempt_count: i32,

    /// A string representing the user agent of the client during the OTP transaction.
    /// This information can be useful for auditing purposes and to enhance security measures,
    /// helping to determine the legitimacy of the request based on known characteristics of the client's software.
    pub user_agent: Option<UserAgent>,

    /// The IP address from which the OTP request was made. Recording IP addresses can aid in security audits
    /// and help in identifying suspicious activities or patterns of abuse, such as repeated failed attempts
    /// from the same IP address or unusual locations.
    pub ip_address: Option<IPAddress>,

    pub persistent: bool,
}

impl UserOtpToken {
    pub fn new(
        user_id: String,
        otp_email_hash: Option<String>,
        otp_email_currently_valid: bool,
        otp_app_hash: Option<String>,
        otp_app_currently_valid: bool,
        otp_app_mnemonic: Option<String>,
        expiry: Option<DateTime<Utc>>,
        attempt_count: i32,
        user_agent: Option<UserAgent>,
        ip_address: Option<IPAddress>,
        persistent: bool,
    ) -> Self {
        Self {
            user_id,
            otp_email_hash,
            otp_email_currently_valid,
            otp_app_hash,
            otp_app_currently_valid,
            otp_app_mnemonic,
            expiry,
            attempt_count,
            user_agent,
            ip_address,
            persistent,
        }
    }
}
